<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stack'd | BrainSmacks</title>
<meta name="description" content="Stack'd — a 3D block stacking physics game. Stack random shapes as high as you can!">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;overflow:hidden;background:#1a1520}
body{font-family:'Segoe UI',system-ui,sans-serif;color:#e2e2e6;display:flex;flex-direction:column;align-items:center}
#top-bar{width:100%;display:flex;justify-content:space-between;align-items:center;padding:6px 16px;background:rgba(14,14,18,0.8);z-index:10;position:relative}
#top-bar a{color:#a78bfa;text-decoration:none;font-size:13px}
#top-bar h1{font-size:20px;color:#c4b5fd;letter-spacing:2px}
#game-container{flex:1;width:100%;position:relative;cursor:grab}
#game-container:active{cursor:grabbing}
#hud{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:20px;font-size:15px;font-weight:600;text-shadow:0 2px 4px rgba(0,0,0,0.6);z-index:5;pointer-events:none}
.hud-item{display:flex;align-items:center;gap:6px}
#height-display{color:#c4b5fd}
#blocks-display{color:#60a5fa}
#best-display{color:#fbbf24}
#controls-panel{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:5}
#controls-panel button{background:rgba(124,58,237,0.85);color:#fff;border:none;border-radius:8px;padding:10px 20px;font-size:14px;font-weight:600;cursor:pointer;transition:background .15s,transform .1s;backdrop-filter:blur(8px)}
#controls-panel button:hover{background:rgba(109,40,217,0.9);transform:translateY(-1px)}
#controls-panel button:disabled{background:rgba(51,51,51,0.7);color:#666;cursor:default;transform:none}
#controls-panel button.commit{background:rgba(34,197,94,0.85)}
#controls-panel button.commit:hover{background:rgba(22,163,74,0.9)}
#shape-preview{position:absolute;top:10px;right:16px;background:rgba(20,20,30,0.85);border:1px solid #333;border-radius:10px;padding:10px 14px;z-index:5;text-align:center;backdrop-filter:blur(8px)}
#shape-preview .label{font-size:11px;color:#6b7280;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px}
#shape-preview .name{font-size:14px;font-weight:700;color:#c4b5fd}
#instructions{position:absolute;bottom:70px;left:50%;transform:translateX(-50%);font-size:12px;color:#6b7280;z-index:5;text-align:center;pointer-events:none}
#overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(14,14,18,0.92);z-index:20;transition:opacity .3s}
#overlay.hidden{opacity:0;pointer-events:none}
#overlay h2{font-size:36px;color:#c4b5fd;margin-bottom:10px;letter-spacing:2px}
#overlay p{color:#9ca3af;font-size:15px;margin-bottom:16px;max-width:440px;text-align:center;line-height:1.6}
#overlay .stat{font-size:20px;color:#e2e2e6;margin:4px 0}
#overlay button{background:#7c3aed;color:#fff;border:none;border-radius:8px;padding:12px 36px;font-size:16px;font-weight:700;cursor:pointer;margin-top:12px}
#overlay button:hover{background:#6d28d9}
#game-over-overlay{position:absolute;inset:0;display:none;flex-direction:column;align-items:center;justify-content:center;background:rgba(14,14,18,0.92);z-index:20}
#game-over-overlay.show{display:flex}
#game-over-overlay h2{font-size:32px;color:#f87171;margin-bottom:8px}
#game-over-overlay .stat{font-size:18px;color:#e2e2e6;margin:4px 0}
#game-over-overlay button{background:#7c3aed;color:#fff;border:none;border-radius:8px;padding:12px 36px;font-size:16px;font-weight:700;cursor:pointer;margin-top:16px}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.170.0",
    "three/addons/": "https://esm.sh/three@0.170.0/examples/jsm/",
    "cannon-es": "https://esm.sh/cannon-es@0.20.0"
  }
}
</script>
</head>
<body>
<div id="top-bar">
  <a href="/">BrainSmacks</a>
  <h1>STACK'D</h1>
  <span id="best-display" class="hud-item">Best: 0</span>
</div>
<div id="game-container">
  <div id="hud">
    <span id="height-display" class="hud-item">Height: 0</span>
    <span id="blocks-display" class="hud-item">Blocks: 0</span>
  </div>
  <div id="shape-preview">
    <div class="label">Next Shape</div>
    <div class="name" id="shape-name">—</div>
  </div>
  <div id="instructions">
    Arrow keys / WASD = move | Q/E = rotate | Space = drop | Enter = commit
  </div>
  <div id="controls-panel">
    <button onclick="GAME.rotateBlock()" id="btn-rotate">Rotate</button>
    <button onclick="GAME.dropBlock()" id="btn-drop">Drop</button>
    <button onclick="GAME.commitBlock()" id="btn-commit" class="commit" disabled>Commit</button>
  </div>
  <div id="overlay">
    <h2>STACK'D</h2>
    <p>Stack random 3D blocks as high as you can! Place carefully — if your tower topples, it's game over.</p>
    <button onclick="GAME.start()">Start Stacking</button>
  </div>
  <div id="game-over-overlay">
    <h2>TOPPLED!</h2>
    <div class="stat" id="go-height">Height: 0</div>
    <div class="stat" id="go-blocks">Blocks: 0</div>
    <div class="stat" id="go-best">Best: 0</div>
    <button onclick="GAME.start()">Try Again</button>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as CANNON from 'cannon-es';

// ==================== SHAPE DEFINITIONS ====================
// Each shape: name, geometry dims, color, mass multiplier
const SHAPES = [
  { name:'Cube', w:1, h:1, d:1, color:0xe74c3c, mass:1 },
  { name:'Flat Brick', w:2, h:0.5, d:1, color:0x3498db, mass:1.2 },
  { name:'Long Plank', w:3, h:0.5, d:1, color:0x2ecc71, mass:1.5 },
  { name:'Tall Block', w:1, h:2, d:1, color:0xf39c12, mass:1.3 },
  { name:'Wide Slab', w:2, h:0.5, d:2, color:0x9b59b6, mass:1.6 },
  { name:'L-Shape', w:1, h:1, d:1, color:0xe67e22, mass:1.1, compound:'L' },
  { name:'T-Shape', w:1, h:1, d:1, color:0x1abc9c, mass:1.3, compound:'T' },
  { name:'Thin Beam', w:3, h:0.4, d:0.6, color:0xf1c40f, mass:1.0 },
  { name:'Pillar', w:0.6, h:2.5, d:0.6, color:0xe91e63, mass:1.2 },
  { name:'Step Block', w:1, h:1, d:1, color:0x00bcd4, mass:1.2, compound:'step' },
];

// ==================== TOY BOX MATERIALS ====================
function createToyMaterial(color) {
  return new THREE.MeshStandardMaterial({
    color,
    roughness: 0.35,
    metalness: 0.05,
    envMapIntensity: 0.6,
  });
}

function createWoodMaterial() {
  const canvas = document.createElement('canvas');
  canvas.width = 256; canvas.height = 256;
  const ctx = canvas.getContext('2d');
  // Base wood color
  ctx.fillStyle = '#c4a265';
  ctx.fillRect(0, 0, 256, 256);
  // Wood grain lines
  for (let i = 0; i < 40; i++) {
    ctx.strokeStyle = `rgba(139,90,43,${0.05 + Math.random() * 0.1})`;
    ctx.lineWidth = 1 + Math.random() * 2;
    ctx.beginPath();
    const y = Math.random() * 256;
    ctx.moveTo(0, y);
    for (let x = 0; x < 256; x += 10) {
      ctx.lineTo(x, y + Math.sin(x * 0.05) * 3 + (Math.random() - 0.5) * 2);
    }
    ctx.stroke();
  }
  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return new THREE.MeshStandardMaterial({
    map: tex, roughness: 0.6, metalness: 0,
  });
}

// ==================== GAME ====================
const GAME = {
  scene: null, camera: null, renderer: null, controls: null,
  world: null, clock: new THREE.Clock(),
  bodies: [], meshes: [],
  currentBlock: null, currentBody: null, currentMesh: null,
  phase: 'idle', // idle | placing | dropping | settling | gameover
  blocksPlaced: 0, maxHeight: 0, best: 0,
  dropY: 12, settleTimer: 0, settleChecks: 0,
  groundY: 0,

  init() {
    // Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1520);
    this.scene.fog = new THREE.Fog(0x1a1520, 25, 60);

    // Camera
    const container = document.getElementById('game-container');
    const aspect = container.clientWidth / container.clientHeight;
    this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
    this.camera.position.set(6, 8, 10);
    this.camera.lookAt(0, 3, 0);

    // Renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.2;
    container.insertBefore(this.renderer.domElement, container.firstChild);

    // Controls
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.target.set(0, 3, 0);
    this.controls.enablePan = false;
    this.controls.minDistance = 5;
    this.controls.maxDistance = 25;
    this.controls.maxPolarAngle = Math.PI * 0.48;
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.08;

    // Lighting
    const amb = new THREE.AmbientLight(0xfff5e6, 0.5);
    this.scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(5, 12, 8);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.left = -10; dir.shadow.camera.right = 10;
    dir.shadow.camera.top = 15; dir.shadow.camera.bottom = -5;
    dir.shadow.camera.near = 0.5; dir.shadow.camera.far = 30;
    dir.shadow.bias = -0.001;
    this.scene.add(dir);
    const fill = new THREE.DirectionalLight(0x8888ff, 0.3);
    fill.position.set(-4, 6, -4);
    this.scene.add(fill);
    const rim = new THREE.PointLight(0xff8844, 0.4, 20);
    rim.position.set(-3, 8, 5);
    this.scene.add(rim);

    // Environment map for reflections
    const pmremGen = new THREE.PMREMGenerator(this.renderer);
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0x2a2030);
    const envLight = new THREE.HemisphereLight(0xfff5e6, 0x1a1520, 1);
    envScene.add(envLight);
    const envMap = pmremGen.fromScene(envScene).texture;
    this.scene.environment = envMap;
    pmremGen.dispose();

    // Ground — toy box floor
    this.createGround();

    // Physics
    this.world = new CANNON.World();
    this.world.gravity.set(0, -15, 0);
    this.world.broadphase = new CANNON.NaiveBroadphase();
    this.world.solver.iterations = 15;
    this.world.solver.tolerance = 0.001;

    // Ground physics
    const groundBody = new CANNON.Body({ mass: 0, material: new CANNON.Material('ground') });
    groundBody.addShape(new CANNON.Box(new CANNON.Vec3(10, 0.5, 10)));
    groundBody.position.set(0, -0.5, 0);
    this.world.addBody(groundBody);

    // Contact material
    const blockMat = new CANNON.Material('block');
    const contact = new CANNON.ContactMaterial(blockMat, blockMat, {
      friction: 0.7, restitution: 0.05
    });
    const groundContact = new CANNON.ContactMaterial(groundBody.material, blockMat, {
      friction: 0.8, restitution: 0.03
    });
    this.world.addContactMaterial(contact);
    this.world.addContactMaterial(groundContact);
    this.blockMaterial = blockMat;

    // Load best
    this.best = parseInt(localStorage.getItem('stackd_best')) || 0;
    document.getElementById('best-display').textContent = 'Best: ' + this.best;

    // Input
    document.addEventListener('keydown', e => this.onKey(e));

    // Resize
    window.addEventListener('resize', () => {
      const c = document.getElementById('game-container');
      this.camera.aspect = c.clientWidth / c.clientHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(c.clientWidth, c.clientHeight);
    });

    this.animate();
  },

  createGround() {
    // Wooden table/toy box floor
    const woodMat = createWoodMaterial();
    const floor = new THREE.Mesh(
      new THREE.BoxGeometry(20, 1, 20),
      woodMat
    );
    floor.position.y = -0.5;
    floor.receiveShadow = true;
    this.scene.add(floor);

    // Toy box walls (subtle)
    const wallMat = new THREE.MeshStandardMaterial({
      color: 0x8b6b4a, roughness: 0.7, metalness: 0
    });
    const wallH = 0.8;
    const walls = [
      { pos: [0, wallH/2, -10], size: [20, wallH, 0.3] },
      { pos: [0, wallH/2, 10], size: [20, wallH, 0.3] },
      { pos: [-10, wallH/2, 0], size: [0.3, wallH, 20] },
      { pos: [10, wallH/2, 0], size: [0.3, wallH, 20] },
    ];
    walls.forEach(w => {
      const m = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
      m.position.set(...w.pos);
      m.receiveShadow = true;
      this.scene.add(m);
    });

    // Grid lines on floor for alignment
    const gridHelper = new THREE.GridHelper(8, 8, 0x4a3a2a, 0x3a2a1a);
    gridHelper.position.y = 0.01;
    this.scene.add(gridHelper);
  },

  // ==================== GAME FLOW ====================
  start() {
    // Clear old blocks
    this.bodies.forEach(b => this.world.removeBody(b));
    this.meshes.forEach(m => this.scene.remove(m));
    this.bodies = []; this.meshes = [];
    if (this.currentMesh) this.scene.remove(this.currentMesh);
    if (this.currentBody) this.world.removeBody(this.currentBody);
    this.currentMesh = null; this.currentBody = null;

    this.blocksPlaced = 0; this.maxHeight = 0;
    this.phase = 'idle';
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('game-over-overlay').classList.remove('show');
    this.updateHUD();

    // Camera reset
    this.camera.position.set(6, 8, 10);
    this.controls.target.set(0, 3, 0);

    this.spawnNextBlock();
  },

  spawnNextBlock() {
    const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
    this.currentBlock = shape;
    document.getElementById('shape-name').textContent = shape.name;
    document.getElementById('shape-name').style.color = '#' + shape.color.toString(16).padStart(6, '0');

    // Create mesh
    let mesh, body;

    if (shape.compound === 'L') {
      mesh = this.createCompoundMesh_L(shape);
      body = this.createCompoundBody_L(shape);
    } else if (shape.compound === 'T') {
      mesh = this.createCompoundMesh_T(shape);
      body = this.createCompoundBody_T(shape);
    } else if (shape.compound === 'step') {
      mesh = this.createCompoundMesh_Step(shape);
      body = this.createCompoundBody_Step(shape);
    } else {
      const geo = new THREE.BoxGeometry(shape.w, shape.h, shape.d);
      // Rounded edges
      mesh = new THREE.Mesh(geo, createToyMaterial(shape.color));
      mesh.castShadow = true;

      const halfExtents = new CANNON.Vec3(shape.w/2, shape.h/2, shape.d/2);
      body = new CANNON.Body({
        mass: shape.mass,
        material: this.blockMaterial,
        shape: new CANNON.Box(halfExtents),
        linearDamping: 0.4,
        angularDamping: 0.6
      });
    }

    // Position above stack
    const spawnY = Math.max(this.maxHeight + 4, 8);
    this.dropY = spawnY;
    mesh.position.set(0, spawnY, 0);
    body.position.set(0, spawnY, 0);
    body.type = CANNON.Body.KINEMATIC;
    body.velocity.set(0, 0, 0);
    body.angularVelocity.set(0, 0, 0);

    this.scene.add(mesh);
    this.world.addBody(body);
    this.currentMesh = mesh;
    this.currentBody = body;
    this.phase = 'placing';

    document.getElementById('btn-drop').disabled = false;
    document.getElementById('btn-commit').disabled = true;
    document.getElementById('btn-rotate').disabled = false;
  },

  // ==================== COMPOUND SHAPES ====================
  createCompoundMesh_L(shape) {
    const group = new THREE.Group();
    const mat = createToyMaterial(shape.color);
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m1.castShadow = true;
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m2.position.set(1, 0, 0); m2.castShadow = true;
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m3.position.set(0, 1, 0); m3.castShadow = true;
    group.add(m1, m2, m3);
    return group;
  },
  createCompoundBody_L(shape) {
    const body = new CANNON.Body({ mass: shape.mass, material: this.blockMaterial, linearDamping: 0.4, angularDamping: 0.6 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 1, 0));
    return body;
  },

  createCompoundMesh_T(shape) {
    const group = new THREE.Group();
    const mat = createToyMaterial(shape.color);
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m1.position.set(-1, 0, 0); m1.castShadow = true;
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m2.castShadow = true;
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m3.position.set(1, 0, 0); m3.castShadow = true;
    const m4 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m4.position.set(0, 1, 0); m4.castShadow = true;
    group.add(m1, m2, m3, m4);
    return group;
  },
  createCompoundBody_T(shape) {
    const body = new CANNON.Body({ mass: shape.mass, material: this.blockMaterial, linearDamping: 0.4, angularDamping: 0.6 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(-1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 1, 0));
    return body;
  },

  createCompoundMesh_Step(shape) {
    const group = new THREE.Group();
    const mat = createToyMaterial(shape.color);
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m1.castShadow = true;
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m2.position.set(1, 0, 0); m2.castShadow = true;
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m3.position.set(1, 1, 0); m3.castShadow = true;
    group.add(m1, m2, m3);
    return group;
  },
  createCompoundBody_Step(shape) {
    const body = new CANNON.Body({ mass: shape.mass, material: this.blockMaterial, linearDamping: 0.4, angularDamping: 0.6 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 1, 0));
    return body;
  },

  // ==================== CONTROLS ====================
  moveBlock(dx, dz) {
    if (this.phase !== 'placing' || !this.currentBody) return;
    const p = this.currentBody.position;
    p.x = Math.max(-3, Math.min(3, p.x + dx * 0.5));
    p.z = Math.max(-3, Math.min(3, p.z + dz * 0.5));
    this.syncMesh();
  },

  rotateBlock() {
    if (this.phase !== 'placing' || !this.currentBody) return;
    const q = this.currentBody.quaternion;
    const rot = new CANNON.Quaternion();
    rot.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 4);
    q.copy(rot.mult(q));
    this.syncMesh();
  },

  dropBlock() {
    if (this.phase !== 'placing' || !this.currentBody) return;
    this.phase = 'dropping';
    this.currentBody.type = CANNON.Body.DYNAMIC;
    this.currentBody.wakeUp();
    document.getElementById('btn-drop').disabled = true;
    document.getElementById('btn-rotate').disabled = true;

    // Wait for it to settle
    this.settleTimer = 0;
    this.settleChecks = 0;
  },

  commitBlock() {
    if (this.phase !== 'settling') return;
    // Finalize this block
    this.bodies.push(this.currentBody);
    this.meshes.push(this.currentMesh);

    // Calculate max height
    const pos = this.currentBody.position;
    const h = pos.y + 1; // approximate top
    if (h > this.maxHeight) this.maxHeight = h;

    this.blocksPlaced++;
    this.currentMesh = null;
    this.currentBody = null;
    this.phase = 'idle';

    // Move camera up with stack
    if (this.maxHeight > 5) {
      this.controls.target.y = this.maxHeight * 0.5;
      this.camera.position.y = this.maxHeight + 4;
    }

    this.updateHUD();
    document.getElementById('btn-commit').disabled = true;

    // Spawn next
    setTimeout(() => this.spawnNextBlock(), 500);
  },

  // ==================== TILT/FALL DETECTION ====================
  checkStability() {
    // Check if any block has fallen off the platform or tipped over too far
    for (const body of this.bodies) {
      // Fallen off table
      if (body.position.y < -2) return 'fallen';
      // Way off center
      if (Math.abs(body.position.x) > 8 || Math.abs(body.position.z) > 8) return 'fallen';
    }

    // Check current block too if it exists
    if (this.currentBody) {
      if (this.currentBody.position.y < -2) return 'fallen';
    }

    // Check if stack is still moving significantly
    let totalVelocity = 0;
    for (const body of this.bodies) {
      totalVelocity += body.velocity.length();
      totalVelocity += body.angularVelocity.length();
    }
    if (this.currentBody && this.currentBody.type === CANNON.Body.DYNAMIC) {
      totalVelocity += this.currentBody.velocity.length();
      totalVelocity += this.currentBody.angularVelocity.length();
    }

    if (totalVelocity < 0.3) return 'stable';
    return 'moving';
  },

  gameOver() {
    this.phase = 'gameover';
    if (this.blocksPlaced > this.best) {
      this.best = this.blocksPlaced;
      localStorage.setItem('stackd_best', this.best);
      document.getElementById('best-display').textContent = 'Best: ' + this.best;
    }
    document.getElementById('go-height').textContent = 'Height: ' + this.maxHeight.toFixed(1);
    document.getElementById('go-blocks').textContent = 'Blocks: ' + this.blocksPlaced;
    document.getElementById('go-best').textContent = 'Best: ' + this.best + ' blocks';
    document.getElementById('game-over-overlay').classList.add('show');
  },

  // ==================== SYNC & UPDATE ====================
  syncMesh() {
    if (!this.currentMesh || !this.currentBody) return;
    this.currentMesh.position.copy(this.currentBody.position);
    this.currentMesh.quaternion.copy(this.currentBody.quaternion);
  },

  syncAllMeshes() {
    for (let i = 0; i < this.bodies.length; i++) {
      this.meshes[i].position.copy(this.bodies[i].position);
      this.meshes[i].quaternion.copy(this.bodies[i].quaternion);
    }
    this.syncMesh();
  },

  updateHUD() {
    document.getElementById('height-display').textContent = 'Height: ' + this.maxHeight.toFixed(1);
    document.getElementById('blocks-display').textContent = 'Blocks: ' + this.blocksPlaced;
  },

  onKey(e) {
    if (this.phase === 'placing') {
      switch(e.key) {
        case 'ArrowLeft': case 'a': case 'A': this.moveBlock(-1, 0); break;
        case 'ArrowRight': case 'd': case 'D': this.moveBlock(1, 0); break;
        case 'ArrowUp': case 'w': case 'W': this.moveBlock(0, -1); break;
        case 'ArrowDown': case 's': case 'S': this.moveBlock(0, 1); break;
        case 'q': case 'Q': this.rotateBlock(); break;
        case 'e': case 'E':
          const q2 = this.currentBody.quaternion;
          const rot2 = new CANNON.Quaternion();
          rot2.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 4);
          q2.copy(rot2.mult(q2));
          this.syncMesh();
          break;
        case ' ': e.preventDefault(); this.dropBlock(); break;
      }
    }
    if (this.phase === 'settling' && e.key === 'Enter') {
      this.commitBlock();
    }
  },

  // ==================== GHOST/PREVIEW ====================
  updateGhost() {
    // Show where the block will land (shadow projection)
    if (this.phase !== 'placing' || !this.currentBody) return;
    // Simple: just highlight the ground position
  },

  // ==================== ANIMATION LOOP ====================
  animate() {
    requestAnimationFrame(() => this.animate());

    const dt = Math.min(this.clock.getDelta(), 0.05);

    // Physics step
    if (this.phase !== 'idle' && this.phase !== 'gameover') {
      this.world.step(1/60, dt, 3);
      this.syncAllMeshes();
    }

    // Dropping phase: check if settled
    if (this.phase === 'dropping') {
      this.settleTimer += dt;
      const stability = this.checkStability();

      if (stability === 'fallen') {
        this.gameOver();
      } else if (stability === 'stable' && this.settleTimer > 0.5) {
        this.phase = 'settling';
        document.getElementById('btn-commit').disabled = false;
      } else if (this.settleTimer > 8) {
        // Taking too long, force settle or game over
        const stability2 = this.checkStability();
        if (stability2 === 'fallen') this.gameOver();
        else {
          this.phase = 'settling';
          document.getElementById('btn-commit').disabled = false;
        }
      }
    }

    // Settling phase: keep checking for late falls
    if (this.phase === 'settling') {
      this.settleTimer += dt;
      const stability = this.checkStability();
      if (stability === 'fallen') this.gameOver();
    }

    // Float animation for placing phase
    if (this.phase === 'placing' && this.currentMesh) {
      const t = performance.now() * 0.001;
      this.currentMesh.position.y = this.dropY + Math.sin(t * 2) * 0.15;
      this.currentBody.position.y = this.currentMesh.position.y;
      // Subtle glow pulse
      if (this.currentMesh.material) {
        this.currentMesh.material.emissive = new THREE.Color(this.currentBlock.color);
        this.currentMesh.material.emissiveIntensity = 0.1 + Math.sin(t * 3) * 0.05;
      }
    }

    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }
};

// Expose to global for onclick handlers
window.GAME = GAME;
GAME.init();
</script>
</body>
</html>
