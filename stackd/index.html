<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stack'd | BrainSmacks</title>
<meta name="description" content="Stack'd — a 3D block stacking physics game. Stack random shapes as high as you can!">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;overflow:hidden;background:#1a1520}
body{font-family:'Segoe UI',system-ui,sans-serif;color:#e2e2e6;display:flex;flex-direction:column;align-items:center}
#top-bar{width:100%;display:flex;justify-content:space-between;align-items:center;padding:6px 16px;background:rgba(14,14,18,0.8);z-index:10;position:relative}
#top-bar a{color:#a78bfa;text-decoration:none;font-size:13px}
#top-bar h1{font-size:20px;color:#c4b5fd;letter-spacing:2px}
#game-container{flex:1;width:100%;position:relative}
#hud{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:20px;font-size:15px;font-weight:600;text-shadow:0 2px 4px rgba(0,0,0,0.6);z-index:5;pointer-events:none}
.hud-item{display:flex;align-items:center;gap:6px}
#height-display{color:#c4b5fd}
#blocks-display{color:#60a5fa}
#best-display{color:#fbbf24}
#controls-panel{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:5}
#controls-panel button{background:rgba(124,58,237,0.85);color:#fff;border:none;border-radius:8px;padding:10px 20px;font-size:14px;font-weight:600;cursor:pointer;transition:background .15s,transform .1s;backdrop-filter:blur(8px)}
#controls-panel button:hover{background:rgba(109,40,217,0.9);transform:translateY(-1px)}
#controls-panel button:disabled{background:rgba(51,51,51,0.7);color:#666;cursor:default;transform:none}
#shape-preview{position:absolute;top:10px;right:16px;background:rgba(20,20,30,0.85);border:1px solid #333;border-radius:10px;padding:10px 14px;z-index:5;text-align:center;backdrop-filter:blur(8px)}
#shape-preview .label{font-size:11px;color:#6b7280;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px}
#shape-preview .name{font-size:14px;font-weight:700;color:#c4b5fd}
#instructions{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);font-size:12px;color:#6b7280;z-index:5;text-align:center;pointer-events:none;line-height:1.6}
#overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(14,14,18,0.92);z-index:20;transition:opacity .3s}
#overlay.hidden{opacity:0;pointer-events:none}
#overlay h2{font-size:36px;color:#c4b5fd;margin-bottom:10px;letter-spacing:2px}
#overlay p{color:#9ca3af;font-size:15px;margin-bottom:16px;max-width:440px;text-align:center;line-height:1.6}
#overlay button{background:#7c3aed;color:#fff;border:none;border-radius:8px;padding:12px 36px;font-size:16px;font-weight:700;cursor:pointer;margin-top:12px}
#overlay button:hover{background:#6d28d9}
#game-over-overlay{position:absolute;inset:0;display:none;flex-direction:column;align-items:center;justify-content:center;background:rgba(14,14,18,0.92);z-index:20}
#game-over-overlay.show{display:flex}
#game-over-overlay h2{font-size:32px;color:#f87171;margin-bottom:8px}
#game-over-overlay .stat{font-size:18px;color:#e2e2e6;margin:4px 0}
#game-over-overlay button{background:#7c3aed;color:#fff;border:none;border-radius:8px;padding:12px 36px;font-size:16px;font-weight:700;cursor:pointer;margin-top:16px}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.170.0",
    "three/addons/": "https://esm.sh/three@0.170.0/examples/jsm/",
    "cannon-es": "https://esm.sh/cannon-es@0.20.0"
  }
}
</script>
</head>
<body>
<div id="top-bar">
  <a href="/">BrainSmacks</a>
  <h1>STACK'D</h1>
  <span id="best-display" class="hud-item">Best: 0</span>
</div>
<div id="game-container">
  <div id="hud">
    <span id="height-display" class="hud-item">Height: 0</span>
    <span id="blocks-display" class="hud-item">Blocks: 0</span>
  </div>
  <div id="shape-preview">
    <div class="label">Next Shape</div>
    <div class="name" id="shape-name">—</div>
  </div>
  <div id="instructions">
    Left-click &amp; drag to position | Q / E to rotate while holding | Release to drop
  </div>
  <div id="overlay">
    <h2>STACK'D</h2>
    <p>Stack random 3D blocks as high as you can! Click and drag to position, Q/E to rotate, then release to drop. If anything falls off the edge — game over!</p>
    <button onclick="GAME.start()">Start Stacking</button>
  </div>
  <div id="game-over-overlay">
    <h2>TOPPLED!</h2>
    <div class="stat" id="go-height">Height: 0</div>
    <div class="stat" id="go-blocks">Blocks: 0</div>
    <div class="stat" id="go-best">Best: 0</div>
    <button onclick="GAME.start()">Try Again</button>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as CANNON from 'cannon-es';

// ==================== CONSTANTS ====================
const PLATFORM_HALF = 3; // platform is 6×6 units (smaller grid)
const PLATFORM_SIZE = PLATFORM_HALF * 2;

// ==================== SHAPE DEFINITIONS ====================
const SHAPES = [
  { name:'Cube', w:1, h:1, d:1, color:0xe74c3c, mass:1 },
  { name:'Flat Brick', w:2, h:0.5, d:1, color:0x3498db, mass:1.2 },
  { name:'Long Plank', w:3, h:0.5, d:1, color:0x2ecc71, mass:1.5 },
  { name:'Tall Block', w:1, h:2, d:1, color:0xf39c12, mass:1.3 },
  { name:'Wide Slab', w:2, h:0.5, d:2, color:0x9b59b6, mass:1.6 },
  { name:'L-Shape', w:1, h:1, d:1, color:0xe67e22, mass:1.1, compound:'L' },
  { name:'T-Shape', w:1, h:1, d:1, color:0x1abc9c, mass:1.3, compound:'T' },
  { name:'Thin Beam', w:3, h:0.4, d:0.6, color:0xf1c40f, mass:1.0 },
  { name:'Pillar', w:0.6, h:2.5, d:0.6, color:0xe91e63, mass:1.2 },
  { name:'Step Block', w:1, h:1, d:1, color:0x00bcd4, mass:1.2, compound:'step' },
];

// ==================== TOY BOX MATERIALS ====================
function createToyMaterial(color) {
  return new THREE.MeshStandardMaterial({
    color,
    roughness: 0.35,
    metalness: 0.05,
    envMapIntensity: 0.6,
  });
}

function createWoodMaterial() {
  const canvas = document.createElement('canvas');
  canvas.width = 256; canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#c4a265';
  ctx.fillRect(0, 0, 256, 256);
  for (let i = 0; i < 40; i++) {
    ctx.strokeStyle = `rgba(139,90,43,${0.05 + Math.random() * 0.1})`;
    ctx.lineWidth = 1 + Math.random() * 2;
    ctx.beginPath();
    const y = Math.random() * 256;
    ctx.moveTo(0, y);
    for (let x = 0; x < 256; x += 10) {
      ctx.lineTo(x, y + Math.sin(x * 0.05) * 3 + (Math.random() - 0.5) * 2);
    }
    ctx.stroke();
  }
  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return new THREE.MeshStandardMaterial({
    map: tex, roughness: 0.6, metalness: 0,
  });
}

// ==================== GAME ====================
const GAME = {
  scene: null, camera: null, renderer: null, controls: null,
  world: null, clock: new THREE.Clock(),
  bodies: [], meshes: [],
  currentBlock: null, currentBody: null, currentMesh: null,
  phase: 'idle', // idle | placing | dropping | settling | gameover
  blocksPlaced: 0, maxHeight: 0, best: 0,
  dropY: 12, settleTimer: 0,
  // Drag state
  isDragging: false,
  raycaster: new THREE.Raycaster(),
  mouse: new THREE.Vector2(),
  dragPlane: null, // invisible plane at spawn height for raycasting

  init() {
    // Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1520);
    this.scene.fog = new THREE.Fog(0x1a1520, 25, 60);

    // Camera
    const container = document.getElementById('game-container');
    const aspect = container.clientWidth / container.clientHeight;
    this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
    this.camera.position.set(6, 8, 10);
    this.camera.lookAt(0, 3, 0);

    // Renderer — NO shadows
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = false;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.2;
    container.insertBefore(this.renderer.domElement, container.firstChild);

    // Orbit controls — only right-click drag to orbit
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.target.set(0, 3, 0);
    this.controls.enablePan = false;
    this.controls.minDistance = 5;
    this.controls.maxDistance = 25;
    this.controls.maxPolarAngle = Math.PI * 0.48;
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.08;
    // Disable left-click orbit (we use it for drag-to-place)
    this.controls.mouseButtons = {
      LEFT: null,
      MIDDLE: THREE.MOUSE.DOLLY,
      RIGHT: THREE.MOUSE.ROTATE
    };

    // Lighting (no shadow casting)
    const amb = new THREE.AmbientLight(0xfff5e6, 0.6);
    this.scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(5, 12, 8);
    this.scene.add(dir);
    const fill = new THREE.DirectionalLight(0x8888ff, 0.3);
    fill.position.set(-4, 6, -4);
    this.scene.add(fill);
    const rim = new THREE.PointLight(0xff8844, 0.4, 20);
    rim.position.set(-3, 8, 5);
    this.scene.add(rim);

    // Environment map
    const pmremGen = new THREE.PMREMGenerator(this.renderer);
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0x2a2030);
    const envLight = new THREE.HemisphereLight(0xfff5e6, 0x1a1520, 1);
    envScene.add(envLight);
    const envMap = pmremGen.fromScene(envScene).texture;
    this.scene.environment = envMap;
    pmremGen.dispose();

    // Ground
    this.createGround();

    // Invisible drag plane (updated per spawn)
    this.dragPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    this.dragPlane.rotation.x = -Math.PI / 2;
    this.dragPlane.position.y = 10;
    this.scene.add(this.dragPlane);

    // Physics
    this.world = new CANNON.World();
    this.world.gravity.set(0, -15, 0);
    this.world.broadphase = new CANNON.NaiveBroadphase();
    this.world.solver.iterations = 15;
    this.world.solver.tolerance = 0.001;

    // Ground physics — thin platform (only covers the small area)
    const groundBody = new CANNON.Body({ mass: 0, material: new CANNON.Material('ground') });
    groundBody.addShape(new CANNON.Box(new CANNON.Vec3(PLATFORM_HALF, 0.5, PLATFORM_HALF)));
    groundBody.position.set(0, -0.5, 0);
    this.world.addBody(groundBody);

    // Contact materials
    const blockMat = new CANNON.Material('block');
    this.world.addContactMaterial(new CANNON.ContactMaterial(blockMat, blockMat, {
      friction: 0.7, restitution: 0.05
    }));
    this.world.addContactMaterial(new CANNON.ContactMaterial(groundBody.material, blockMat, {
      friction: 0.8, restitution: 0.03
    }));
    this.blockMaterial = blockMat;

    // Load best
    this.best = parseInt(localStorage.getItem('stackd_best')) || 0;
    document.getElementById('best-display').textContent = 'Best: ' + this.best;

    // Input
    document.addEventListener('keydown', e => this.onKey(e));
    const cvs = this.renderer.domElement;
    cvs.addEventListener('mousedown', e => this.onMouseDown(e));
    cvs.addEventListener('mousemove', e => this.onMouseMove(e));
    cvs.addEventListener('mouseup', e => this.onMouseUp(e));
    // Touch support
    cvs.addEventListener('touchstart', e => this.onTouchStart(e), { passive: false });
    cvs.addEventListener('touchmove', e => this.onTouchMove(e), { passive: false });
    cvs.addEventListener('touchend', e => this.onTouchEnd(e));

    // Resize
    window.addEventListener('resize', () => {
      const c = document.getElementById('game-container');
      this.camera.aspect = c.clientWidth / c.clientHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(c.clientWidth, c.clientHeight);
    });

    this.animate();
  },

  createGround() {
    const woodMat = createWoodMaterial();
    // Smaller platform
    const floor = new THREE.Mesh(
      new THREE.BoxGeometry(PLATFORM_SIZE, 1, PLATFORM_SIZE),
      woodMat
    );
    floor.position.y = -0.5;
    this.scene.add(floor);

    // Edge trim (subtle border to show the drop-off)
    const edgeMat = new THREE.MeshStandardMaterial({
      color: 0x8b6b4a, roughness: 0.7, metalness: 0
    });
    const edgeH = 0.15;
    const half = PLATFORM_HALF;
    const edges = [
      { pos: [0, edgeH/2, -half], size: [PLATFORM_SIZE + 0.2, edgeH, 0.1] },
      { pos: [0, edgeH/2, half], size: [PLATFORM_SIZE + 0.2, edgeH, 0.1] },
      { pos: [-half, edgeH/2, 0], size: [0.1, edgeH, PLATFORM_SIZE + 0.2] },
      { pos: [half, edgeH/2, 0], size: [0.1, edgeH, PLATFORM_SIZE + 0.2] },
    ];
    edges.forEach(w => {
      const m = new THREE.Mesh(new THREE.BoxGeometry(...w.size), edgeMat);
      m.position.set(...w.pos);
      this.scene.add(m);
    });

    // Grid lines on floor
    const gridHelper = new THREE.GridHelper(PLATFORM_SIZE, PLATFORM_SIZE, 0x4a3a2a, 0x3a2a1a);
    gridHelper.position.y = 0.01;
    this.scene.add(gridHelper);

    // Void below — dark plane far below to show there's nothing
    const voidMat = new THREE.MeshBasicMaterial({ color: 0x0a0a10 });
    const voidPlane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), voidMat);
    voidPlane.rotation.x = -Math.PI / 2;
    voidPlane.position.y = -15;
    this.scene.add(voidPlane);
  },

  // ==================== MOUSE DRAG ====================
  getMouseNDC(e) {
    const rect = this.renderer.domElement.getBoundingClientRect();
    this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  },

  raycastToPlane() {
    this.raycaster.setFromCamera(this.mouse, this.camera);
    const hits = this.raycaster.intersectObject(this.dragPlane);
    if (hits.length > 0) return hits[0].point;
    return null;
  },

  onMouseDown(e) {
    if (e.button !== 0) return; // left click only
    if (this.phase !== 'placing' || !this.currentBody) return;
    e.preventDefault();
    this.isDragging = true;
    this.getMouseNDC(e);
    const pt = this.raycastToPlane();
    if (pt) {
      this.currentBody.position.x = pt.x;
      this.currentBody.position.z = pt.z;
      this.syncMesh();
    }
  },

  onMouseMove(e) {
    if (!this.isDragging || this.phase !== 'placing' || !this.currentBody) return;
    this.getMouseNDC(e);
    const pt = this.raycastToPlane();
    if (pt) {
      this.currentBody.position.x = pt.x;
      this.currentBody.position.z = pt.z;
      this.syncMesh();
    }
  },

  onMouseUp(e) {
    if (e.button !== 0 || !this.isDragging) return;
    this.isDragging = false;
    if (this.phase === 'placing' && this.currentBody) {
      this.dropBlock();
    }
  },

  // Touch equivalents
  onTouchStart(e) {
    if (this.phase !== 'placing' || !this.currentBody) return;
    if (e.touches.length !== 1) return;
    e.preventDefault();
    this.isDragging = true;
    const t = e.touches[0];
    this.getMouseNDC(t);
    const pt = this.raycastToPlane();
    if (pt) {
      this.currentBody.position.x = pt.x;
      this.currentBody.position.z = pt.z;
      this.syncMesh();
    }
  },
  onTouchMove(e) {
    if (!this.isDragging || this.phase !== 'placing' || !this.currentBody) return;
    e.preventDefault();
    const t = e.touches[0];
    this.getMouseNDC(t);
    const pt = this.raycastToPlane();
    if (pt) {
      this.currentBody.position.x = pt.x;
      this.currentBody.position.z = pt.z;
      this.syncMesh();
    }
  },
  onTouchEnd(e) {
    if (!this.isDragging) return;
    this.isDragging = false;
    if (this.phase === 'placing' && this.currentBody) {
      this.dropBlock();
    }
  },

  // ==================== GAME FLOW ====================
  start() {
    this.bodies.forEach(b => this.world.removeBody(b));
    this.meshes.forEach(m => this.scene.remove(m));
    this.bodies = []; this.meshes = [];
    if (this.currentMesh) this.scene.remove(this.currentMesh);
    if (this.currentBody) this.world.removeBody(this.currentBody);
    this.currentMesh = null; this.currentBody = null;

    this.blocksPlaced = 0; this.maxHeight = 0;
    this.phase = 'idle';
    this.isDragging = false;
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('game-over-overlay').classList.remove('show');
    this.updateHUD();

    this.camera.position.set(6, 8, 10);
    this.controls.target.set(0, 3, 0);

    this.spawnNextBlock();
  },

  spawnNextBlock() {
    const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
    this.currentBlock = shape;
    document.getElementById('shape-name').textContent = shape.name;
    document.getElementById('shape-name').style.color = '#' + shape.color.toString(16).padStart(6, '0');

    let mesh, body;

    if (shape.compound === 'L') {
      mesh = this.createCompoundMesh_L(shape);
      body = this.createCompoundBody_L(shape);
    } else if (shape.compound === 'T') {
      mesh = this.createCompoundMesh_T(shape);
      body = this.createCompoundBody_T(shape);
    } else if (shape.compound === 'step') {
      mesh = this.createCompoundMesh_Step(shape);
      body = this.createCompoundBody_Step(shape);
    } else {
      mesh = new THREE.Mesh(
        new THREE.BoxGeometry(shape.w, shape.h, shape.d),
        createToyMaterial(shape.color)
      );
      body = new CANNON.Body({
        mass: shape.mass,
        material: this.blockMaterial,
        shape: new CANNON.Box(new CANNON.Vec3(shape.w/2, shape.h/2, shape.d/2)),
        linearDamping: 0.4,
        angularDamping: 0.6
      });
    }

    const spawnY = Math.max(this.maxHeight + 4, 8);
    this.dropY = spawnY;
    mesh.position.set(0, spawnY, 0);
    body.position.set(0, spawnY, 0);
    body.type = CANNON.Body.KINEMATIC;
    body.velocity.set(0, 0, 0);
    body.angularVelocity.set(0, 0, 0);

    // Update drag plane height
    this.dragPlane.position.y = spawnY;

    this.scene.add(mesh);
    this.world.addBody(body);
    this.currentMesh = mesh;
    this.currentBody = body;
    this.phase = 'placing';
  },

  // ==================== COMPOUND SHAPES ====================
  createCompoundMesh_L(shape) {
    const group = new THREE.Group();
    const mat = createToyMaterial(shape.color);
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m2.position.set(1, 0, 0);
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m3.position.set(0, 1, 0);
    group.add(m1, m2, m3);
    return group;
  },
  createCompoundBody_L(shape) {
    const body = new CANNON.Body({ mass: shape.mass, material: this.blockMaterial, linearDamping: 0.4, angularDamping: 0.6 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 1, 0));
    return body;
  },

  createCompoundMesh_T(shape) {
    const group = new THREE.Group();
    const mat = createToyMaterial(shape.color);
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m1.position.set(-1, 0, 0);
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m3.position.set(1, 0, 0);
    const m4 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m4.position.set(0, 1, 0);
    group.add(m1, m2, m3, m4);
    return group;
  },
  createCompoundBody_T(shape) {
    const body = new CANNON.Body({ mass: shape.mass, material: this.blockMaterial, linearDamping: 0.4, angularDamping: 0.6 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(-1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 1, 0));
    return body;
  },

  createCompoundMesh_Step(shape) {
    const group = new THREE.Group();
    const mat = createToyMaterial(shape.color);
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m2.position.set(1, 0, 0);
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat); m3.position.set(1, 1, 0);
    group.add(m1, m2, m3);
    return group;
  },
  createCompoundBody_Step(shape) {
    const body = new CANNON.Body({ mass: shape.mass, material: this.blockMaterial, linearDamping: 0.4, angularDamping: 0.6 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(0, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), new CANNON.Vec3(1, 1, 0));
    return body;
  },

  // ==================== CONTROLS ====================
  rotateBlock(dir = 1) {
    if (this.phase !== 'placing' || !this.currentBody) return;
    const q = this.currentBody.quaternion;
    const rot = new CANNON.Quaternion();
    rot.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), dir * Math.PI / 4);
    q.copy(rot.mult(q));
    this.syncMesh();
  },

  dropBlock() {
    if (this.phase !== 'placing' || !this.currentBody) return;
    this.phase = 'dropping';
    this.currentBody.type = CANNON.Body.DYNAMIC;
    this.currentBody.wakeUp();
    this.settleTimer = 0;
  },

  commitBlock() {
    if (this.phase !== 'settling') return;
    this.bodies.push(this.currentBody);
    this.meshes.push(this.currentMesh);

    const pos = this.currentBody.position;
    const h = pos.y + 1;
    if (h > this.maxHeight) this.maxHeight = h;

    this.blocksPlaced++;
    this.currentMesh = null;
    this.currentBody = null;
    this.phase = 'idle';

    if (this.maxHeight > 5) {
      this.controls.target.y = this.maxHeight * 0.5;
      this.camera.position.y = this.maxHeight + 4;
    }

    this.updateHUD();
    setTimeout(() => this.spawnNextBlock(), 500);
  },

  // ==================== FALL DETECTION ====================
  checkStability() {
    // Check if any block fell off the platform or into the void
    for (const body of this.bodies) {
      if (body.position.y < -2) return 'fallen';
      // Off the platform edges
      if (Math.abs(body.position.x) > PLATFORM_HALF + 1 || Math.abs(body.position.z) > PLATFORM_HALF + 1) return 'fallen';
    }
    if (this.currentBody) {
      if (this.currentBody.position.y < -2) return 'fallen';
    }

    let totalVelocity = 0;
    for (const body of this.bodies) {
      totalVelocity += body.velocity.length();
      totalVelocity += body.angularVelocity.length();
    }
    if (this.currentBody && this.currentBody.type === CANNON.Body.DYNAMIC) {
      totalVelocity += this.currentBody.velocity.length();
      totalVelocity += this.currentBody.angularVelocity.length();
    }

    if (totalVelocity < 0.3) return 'stable';
    return 'moving';
  },

  gameOver() {
    this.phase = 'gameover';
    this.isDragging = false;
    if (this.blocksPlaced > this.best) {
      this.best = this.blocksPlaced;
      localStorage.setItem('stackd_best', this.best);
      document.getElementById('best-display').textContent = 'Best: ' + this.best;
    }
    document.getElementById('go-height').textContent = 'Height: ' + this.maxHeight.toFixed(1);
    document.getElementById('go-blocks').textContent = 'Blocks: ' + this.blocksPlaced;
    document.getElementById('go-best').textContent = 'Best: ' + this.best + ' blocks';
    document.getElementById('game-over-overlay').classList.add('show');
  },

  // ==================== SYNC & UPDATE ====================
  syncMesh() {
    if (!this.currentMesh || !this.currentBody) return;
    this.currentMesh.position.copy(this.currentBody.position);
    this.currentMesh.quaternion.copy(this.currentBody.quaternion);
  },

  syncAllMeshes() {
    for (let i = 0; i < this.bodies.length; i++) {
      this.meshes[i].position.copy(this.bodies[i].position);
      this.meshes[i].quaternion.copy(this.bodies[i].quaternion);
    }
    this.syncMesh();
  },

  updateHUD() {
    document.getElementById('height-display').textContent = 'Height: ' + this.maxHeight.toFixed(1);
    document.getElementById('blocks-display').textContent = 'Blocks: ' + this.blocksPlaced;
  },

  onKey(e) {
    if (this.phase === 'placing') {
      switch(e.key) {
        case 'q': case 'Q': this.rotateBlock(1); break;
        case 'e': case 'E': this.rotateBlock(-1); break;
        // Arrow/WASD still work as backup for keyboard players
        case 'ArrowLeft': case 'a': case 'A':
          if (this.currentBody) { this.currentBody.position.x -= 0.5; this.syncMesh(); } break;
        case 'ArrowRight': case 'd': case 'D':
          if (this.currentBody) { this.currentBody.position.x += 0.5; this.syncMesh(); } break;
        case 'ArrowUp': case 'w': case 'W':
          if (this.currentBody) { this.currentBody.position.z -= 0.5; this.syncMesh(); } break;
        case 'ArrowDown': case 's': case 'S':
          if (this.currentBody) { this.currentBody.position.z += 0.5; this.syncMesh(); } break;
        case ' ': e.preventDefault(); this.dropBlock(); break;
      }
    }
    if (this.phase === 'settling' && e.key === 'Enter') {
      this.commitBlock();
    }
  },

  // ==================== ANIMATION LOOP ====================
  animate() {
    requestAnimationFrame(() => this.animate());

    const dt = Math.min(this.clock.getDelta(), 0.05);

    if (this.phase !== 'idle' && this.phase !== 'gameover') {
      this.world.step(1/60, dt, 3);
      this.syncAllMeshes();
    }

    // Dropping: check settle
    if (this.phase === 'dropping') {
      this.settleTimer += dt;
      const stability = this.checkStability();
      if (stability === 'fallen') {
        this.gameOver();
      } else if (stability === 'stable' && this.settleTimer > 0.5) {
        // Auto-commit when settled
        this.phase = 'settling';
        this.commitBlock();
      } else if (this.settleTimer > 8) {
        if (this.checkStability() === 'fallen') this.gameOver();
        else { this.phase = 'settling'; this.commitBlock(); }
      }
    }

    // Settling: keep checking for late falls
    if (this.phase === 'settling') {
      this.settleTimer += dt;
      if (this.checkStability() === 'fallen') this.gameOver();
    }

    // Float animation while placing
    if (this.phase === 'placing' && this.currentMesh) {
      const t = performance.now() * 0.001;
      this.currentMesh.position.y = this.dropY + Math.sin(t * 2) * 0.15;
      this.currentBody.position.y = this.currentMesh.position.y;
      if (this.currentMesh.material) {
        this.currentMesh.material.emissive = new THREE.Color(this.currentBlock.color);
        this.currentMesh.material.emissiveIntensity = 0.1 + Math.sin(t * 3) * 0.05;
      }
    }

    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }
};

window.GAME = GAME;
GAME.init();
</script>
</body>
</html>
